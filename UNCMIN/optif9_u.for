      subroutine optif9_u(nr,n,x,fcn,d1fn_u,d2fn_u,typsiz,fscale,
     &     method,iexp,msg,ndigit,itnlim,iagflg,iahflg,iprint,lounit,
     &     dlt,gradtl,stepmx,steptl,xpls,fpls,gpls,itrmcd,a,wrk)

c*********************************************************************72
c
cc OPTIF9 provides a complete interface to the minimization package.
c
c  Discussion:
c
c    provide complete interface to minimization package.
c    user has full control over options.
c
c  Modified:
c
c    09 January 2009
c
c  Author:
c
c    Robert Schnabel, John Koontz, Barry Weiss
c
c  Reference:
c
c    John Dennis, Robert Schnabel,
c    Numerical Methods for Unconstrained Optimization 
c    and Nonlinear Equations,
c    SIAM, 1996,
c    ISBN13: 978-0-898713-64-0,
c    LC: QA402.5.D44.
c
c    Robert Schnabel, John Koontz, Barry Weiss,
c    A modular system of algorithms for unconstrained minimization,
c    Technical Report CU-CS-240-82, 
c    Computer Science Department,
c    University of Colorado at Boulder, 1982.
c
c  Parameters:
c
c nr           --> row dimension of matrix
c                  the row dimension of the matrices a and wrk
c                  as declared in the user calling routine.
c                  nr must be greater than or equal to n.
c
c n            --> dimension of problem, the number of variables.
c                  the program will abort if n.le.0.
c
c x(n)        <--> on entry: estimate to a root of fcn
c                  on return, the next to the last iterate x(k-1).
c
c fcn          --> name of subroutine to evaluate optimization function
c                  must be declared external in calling routine
c                  the calling statement must be
c                  subroutine fcn(n,x,f) where x is an n vector.
c                  fcn must not change the value of x or n.
c
c d1fn         --> name of subroutine to evaluate gradient
c                  of fcn.  must be declared external in calling routine
c                  the calling statement must be
c                  subroutine d1fn(n,x,g) where x and g are n vectors.
c                  the subroutine must not alter x or n.  on return,
c                  g must be the gradient of f, that is,
c                  g(i)=df/dx(i).  if no analytic gradient routine is
c                  used, the user must use the dummy name d1fcn.
c                  if an analytic gradient is supplied, the program
c                  will automatically compare the gradient with one
c                  generated by finite differences unless msg is
c                  appropriately set.
c
c d2fn         --> name of subroutine to evaluate hessian of
c                  fcn.  must be declared external in calling routine
c                  the subroutine statement must be
c                  subroutine d2fn(nr,n,x,h) where x is a vector
c                  of length n, and h is an n by n matrix stored
c                  with a row dimension of nr.  the subroutine must
c                  not change n, nr, or x.  if no analytic hessian
c                  is to be supplied, the user must use the name
c                  d2fcn.  otherwise, d2fn should store the hessian
c                  in h, that is, h(i,j)=d d(f)/d x(i) d x(j).
c                  if an analytic hessian is supplied, the program
c                  will automatically compare it to one computed by
c                  finite differences, unless msg is appropriately set
c
c typsiz(n)    --> typical size for each component of x
c                  each entry should be positive.  this information
c                  is used to scale the information.  if variables
c                  x(i) and x(j) are typically of much different
c                  magnitudes, the scaling of typsiz may help to
c                  solve the problem.
c
c fscale       --> estimate of scale of objective function
c                  a positive scalar estimating the magnitude of
c                  the optimizing function near the minimum x*.
c                  if too large a value is supplied, the program
c                  may terminate prematurely.
c
c method       --> algorithm to use to solve minimization problem
c                  =1 line search
c                  =2 double dogleg
c                  =3 more-hebdon
c
c iexp         --> =1 if optimization function fcn is expensive to
c                  evaluate, =0 otherwise.  if set then hessian will
c                  be evaluated by secant update instead of
c                  analytically or by finite differences
c
c msg         <--> on input:  (.gt.0) message to inhibit certain
c                  automatic checks.  set msg to a value between
c                  0 and 31 by adding the value of each option
c                  below that is to be indicated.
c                  0=no options.
c                  2=do not check analytic gradient routine d1fn
c                  against a finite difference estimate.
c                  4=do not check analytic hessian routine d2fn
c                  against a finite difference estimate.
c                  8=suppress printing of input state and final
c                  results.
c                  16=print intermediate results.
c
c                  on output: (.lt.0) error code; =0 no error
c
c                  -1 = illegal dimension, n.le.0.
c                  -3 = illegal tolerance on gradient, gradtl.lt.0
c                  -4 = iteration limit itnlim.le.0
c                  -5 = no good digits in optimization function,
c                  ndigit=0.
c                  -21 = probable coding error in user gradient
c                  routine d1fn.  analytic and finite difference
c                  gradients do not agree.
c                  -22 = probable coding error in user hessian
c                  routine d2fn.  analytic and finite difference
c                  hessians do not agree.
c
c ndigit       --> number of good digits in optimization function fcn
c                  negative means function has maximum possible
c                  good digits.  0 is not allowed.  positive
c                  value is appropriate when the function is only
c                  computed approximately via quadrature, iteration
c                  or so on.
c
c itnlim       --> maximum number of allowable iterations
c                  nonpositive values are illegal.  this number
c                  limits the number of iterations to be taken.
c
c iagflg       --> =0 if no analytic gradient supplied, d1fcn to be
c                  used.
c                  =1 if analytic gradient routine supplied.
c
c iahflg       --> =0 if no analytic hessian supplied, d2fcn to be
c                  used.
c                  =1 if analytic hessian routine supplied.
c
c  iprint      --> amount of output desired
c                  0=none,
c                  1=starting, stopping, and errors
c                  2=all that, plus intermediate information
c
c lounit       --> device to which to send output
c                  0 means no output.
c                  6 means output to tty or lineprinter.
c
c dlt          --> trust region radius
c                  not needed when line search used (method=1).
c                  otherwise, if no estimate is known, set dlt=-1.
c                  if an estimate of the maximum reasonable scaled
c                  step is known, set dlt to this value.
c
c gradtl       --> tolerance at which gradient considered close
c                  enough to zero to terminate algorithm
c                  the scaled gradient is a measure of the
c                  relative change in f in each direction x(i),
c                  divided by the relative change in x(i).
c
c stepmx       --> maximum allowable step size
c                  stepmx is used to keep the function from
c                  overflowing, or the arguments from leaving the
c                  area of interest, and to detect divergence.
c
c steptl       --> relative step size at which successive iterates
c                  considered close enough to terminate algorithm
c                  steptl can be set to 10**(-p) where p is the
c                  number of digits of agreement between successive
c                  iterates which the user considers to mean
c                  satisfactory convergence.
c
c xpls(n)     <--  on exit:  xpls is local minimum
c                  if the algorithm has converged.
c
c fpls        <--  on exit:  function value at solution, xpls
c
c gpls(n)     <--  on exit:  gradient at solution xpls
c
c itrmcd      <--  termination code
c                  0=erroneous input detected.  see msg.
c                  1=relative gradient is close to zero.
c                  current iterate is probably solution.
c                  2=successive iterates within tolerance.
c                  current iterate is probably solution.
c                  3=last global step failed to locate a
c                  point lower than xpls.  either xpls is a
c                  local minimum, or the function is too nonlinear,
c                  or steptl is too large.
c                  4=iteration limit exceeded.
c                  5=stepmx maximum stepsize exceeded 5 times
c                  in a row.  either the function is unbounded below,
c                  or becomes asymptotic to a finite value from
c                  above, or stepmx is too small.
c
c a(n,n)       --> workspace for hessian (or estimate)
c                  and its cholesky decomposition
c                  dimensioned (nr,n) in calling program.  the hessian
c                  is not evaluated at the last iterate, so information
c                  in a is slightly out of date on return.
c
c wrk(n,8)     --> workspace
c                  workspace needed by the program.
c
      implicit double precision ( a-h, o-z )

      dimension x(n),xpls(n),gpls(n),typsiz(n)
      dimension a(nr,1),wrk(nr,1)
      external fcn,d1fn_u,d2fn_u
c
c equivalence wrk(n,1) = udiag(n)
c             wrk(n,2) = g(n)
c             wrk(n,3) = p(n)
c             wrk(n,4) = sx(n)
c             wrk(n,5) = wrk0(n)
c             wrk(n,6) = wrk1(n)
c             wrk(n,7) = wrk2(n)
c             wrk(n,8) = wrk3(n)
c
      call optdrv_u(nr,n,x,fcn,d1fn_u,d2fn_u,typsiz,fscale,
     & method,iexp,msg,ndigit,itnlim,iagflg,iahflg,iprint,lounit,
     & dlt,gradtl,stepmx,steptl,xpls,fpls,gpls,itrmcd,
     & a,wrk(1,1),wrk(1,2),wrk(1,3),wrk(1,4),wrk(1,5),
     & wrk(1,6),wrk(1,7),wrk(1,8))

      return
      end
